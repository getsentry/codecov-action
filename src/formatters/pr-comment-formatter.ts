import type {
  AggregatedTestResults,
  TestComparison,
} from "../types/test-results.js";
import type {
  AggregatedCoverageResults,
  CoverageComparison,
} from "../types/coverage.js";

export class PRCommentFormatter {
  /**
   * Format test results and coverage as a markdown comment for PRs
   */
  formatComment(
    testResults?: AggregatedTestResults,
    coverageResults?: AggregatedCoverageResults
  ): string {
    const lines: string[] = [];

    // Main header
    lines.push("## Codecov Action Results ğŸ“Š");
    lines.push("");

    // Add test results section
    if (testResults) {
      this.addTestResultsSection(lines, testResults);
    }

    // Add coverage section
    if (coverageResults) {
      this.addCoverageSection(lines, coverageResults);
    }

    // Footer
    lines.push("---");
    lines.push("*Generated by Codecov Action*");

    return lines.join("\n");
  }

  /**
   * Format only test results as a markdown comment for PRs (backward compatibility)
   */
  formatTestComment(results: AggregatedTestResults): string {
    const lines: string[] = [];

    // Header
    lines.push("## Test Results ğŸ§ª");
    lines.push("");

    // Summary line with emoji indicators
    const passEmoji = results.passedTests > 0 ? "âœ…" : "";
    const failEmoji = results.failedTests > 0 ? "âŒ" : "";
    const skipEmoji = results.skippedTests > 0 ? "â­ï¸" : "";

    const summaryParts: string[] = [];

    if (passEmoji) {
      summaryParts.push(`${passEmoji} **${results.passedTests} passed**`);
    }
    if (failEmoji) {
      summaryParts.push(`${failEmoji} **${results.failedTests} failed**`);
    }
    if (skipEmoji) {
      summaryParts.push(`${skipEmoji} **${results.skippedTests} skipped**`);
    }

    // Add total and pass rate
    summaryParts.push(`**Total: ${results.totalTests}**`);
    summaryParts.push(`**Pass Rate: ${results.passRate}%**`);

    lines.push(summaryParts.join(" | "));
    lines.push("");

    // Execution time
    lines.push(`â±ï¸ **Execution Time:** ${this.formatTime(results.totalTime)}`);
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addComparisonSection(lines, results.comparison);
    }

    // Show failed tests if any
    if (results.failedTests > 0 && results.failedTestCases.length > 0) {
      lines.push("### âŒ Failed Tests");
      lines.push("");

      for (const { suiteName, testCase } of results.failedTestCases) {
        // Test header
        lines.push(`#### \`${testCase.name}\``);
        lines.push(`**File:** \`${testCase.classname}\``);

        if (suiteName && suiteName !== testCase.classname) {
          lines.push(`**Suite:** \`${suiteName}\``);
        }

        if (testCase.failure) {
          lines.push(`**Error:** ${testCase.failure.message}`);
          lines.push("");

          // Stack trace in collapsible details
          if (testCase.failure.content) {
            lines.push("<details>");
            lines.push("<summary>Stack Trace</summary>");
            lines.push("");
            lines.push("```");
            lines.push(testCase.failure.content.trim());
            lines.push("```");
            lines.push("");
            lines.push("</details>");
            lines.push("");
          }
        }
      }
    } else if (results.failedTests === 0) {
      // Success message
      lines.push("### âœ… All Tests Passed!");
      lines.push("");
      lines.push("Great job! All tests are passing successfully.");
      lines.push("");
    }

    // Footer
    lines.push("---");
    lines.push("*Generated by Codecov Action*");

    return lines.join("\n");
  }

  /**
   * Add test results section to the comment
   */
  private addTestResultsSection(
    lines: string[],
    results: AggregatedTestResults
  ): void {
    lines.push("## Test Results ğŸ§ª");
    lines.push("");

    // Summary line with emoji indicators
    const passEmoji = results.passedTests > 0 ? "âœ…" : "";
    const failEmoji = results.failedTests > 0 ? "âŒ" : "";
    const skipEmoji = results.skippedTests > 0 ? "â­ï¸" : "";

    const summaryParts: string[] = [];

    if (passEmoji) {
      summaryParts.push(`${passEmoji} **${results.passedTests} passed**`);
    }
    if (failEmoji) {
      summaryParts.push(`${failEmoji} **${results.failedTests} failed**`);
    }
    if (skipEmoji) {
      summaryParts.push(`${skipEmoji} **${results.skippedTests} skipped**`);
    }

    // Add total and pass rate
    summaryParts.push(`**Total: ${results.totalTests}**`);
    summaryParts.push(`**Pass Rate: ${results.passRate}%**`);

    lines.push(summaryParts.join(" | "));
    lines.push("");

    // Execution time
    lines.push(`â±ï¸ **Execution Time:** ${this.formatTime(results.totalTime)}`);
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addComparisonSection(lines, results.comparison);
    }

    // Show failed tests if any
    if (results.failedTests > 0 && results.failedTestCases.length > 0) {
      lines.push("### âŒ Failed Tests");
      lines.push("");

      for (const { suiteName, testCase } of results.failedTestCases) {
        // Test header
        lines.push(`#### \`${testCase.name}\``);
        lines.push(`**File:** \`${testCase.classname}\``);

        if (suiteName && suiteName !== testCase.classname) {
          lines.push(`**Suite:** \`${suiteName}\``);
        }

        if (testCase.failure) {
          lines.push(`**Error:** ${testCase.failure.message}`);
          lines.push("");

          // Stack trace in collapsible details
          if (testCase.failure.content) {
            lines.push("<details>");
            lines.push("<summary>Stack Trace</summary>");
            lines.push("");
            lines.push("```");
            lines.push(testCase.failure.content.trim());
            lines.push("```");
            lines.push("");
            lines.push("</details>");
            lines.push("");
          }
        }
      }
    } else if (results.failedTests === 0) {
      // Success message
      lines.push("### âœ… All Tests Passed!");
      lines.push("");
      lines.push("Great job! All tests are passing successfully.");
      lines.push("");
    }

    lines.push("");
  }

  /**
   * Add coverage section to the comment
   */
  private addCoverageSection(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    lines.push("## Coverage Report ğŸ¯");
    lines.push("");

    // Coverage summary
    const lineEmoji = this.getCoverageEmoji(results.lineRate);
    const branchEmoji = this.getCoverageEmoji(results.branchRate);

    lines.push("| Metric | Coverage | Covered/Total |");
    lines.push("|--------|----------|---------------|");
    lines.push(
      `| ${lineEmoji} **Line Coverage** | **${results.lineRate}%** | ${results.coveredStatements}/${results.totalStatements} |`
    );
    lines.push(
      `| ${branchEmoji} **Branch Coverage** | **${results.branchRate}%** | ${results.coveredConditionals}/${results.totalConditionals} |`
    );
    lines.push(
      `| ğŸ”§ **Method Coverage** | **${this.calculateMethodCoverage(results)}%** | ${results.coveredMethods}/${results.totalMethods} |`
    );
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addCoverageComparisonSection(lines, results.comparison);
    }

    // Show files with low coverage (< 50%)
    const lowCoverageFiles = results.files.filter(
      (f) => f.lineRate < 50 && f.lineRate > 0
    );
    if (lowCoverageFiles.length > 0) {
      lines.push(
        `### âš ï¸ Files with Low Coverage (${lowCoverageFiles.length})`
      );
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View files with coverage below 50%</summary>");
      lines.push("");
      lines.push("| File | Line Coverage | Branch Coverage |");
      lines.push("|------|---------------|-----------------|");

      // Sort by line rate (lowest first) and limit to top 10
      const sortedFiles = lowCoverageFiles
        .sort((a, b) => a.lineRate - b.lineRate)
        .slice(0, 10);

      for (const file of sortedFiles) {
        const fileName = file.name.length > 50 ? `...${file.name.slice(-47)}` : file.name;
        lines.push(
          `| \`${fileName}\` | ${this.getCoverageEmoji(file.lineRate)} ${file.lineRate}% | ${this.getCoverageEmoji(file.branchRate)} ${file.branchRate}% |`
        );
      }

      if (lowCoverageFiles.length > 10) {
        lines.push(
          `| ... | ... | ${lowCoverageFiles.length - 10} more files |`
        );
      }

      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    lines.push("");
  }

  /**
   * Add coverage comparison section
   */
  private addCoverageComparisonSection(
    lines: string[],
    comparison: CoverageComparison
  ): void {
    lines.push("### ğŸ“Š Coverage Change from Base Branch");
    lines.push("");

    // Improvement or degradation indicator
    if (comparison.improvement) {
      lines.push("#### ğŸ“ˆ Coverage Improved!");
    } else if (
      comparison.deltaLineRate < 0 ||
      comparison.deltaBranchRate < 0
    ) {
      lines.push("#### ğŸ“‰ Coverage Decreased");
    } else {
      lines.push("#### â¡ï¸ Coverage Unchanged");
    }
    lines.push("");

    // Summary table
    lines.push("| Metric | Change |");
    lines.push("|--------|--------|");
    lines.push(
      `| Line Coverage | ${this.formatCoverageDelta(comparison.deltaLineRate)}% |`
    );
    lines.push(
      `| Branch Coverage | ${this.formatCoverageDelta(comparison.deltaBranchRate)}% |`
    );
    lines.push(
      `| Total Statements | ${this.formatDelta(comparison.deltaTotalStatements)} |`
    );
    lines.push(
      `| Covered Statements | ${this.formatDelta(comparison.deltaCoveredStatements)} |`
    );
    lines.push("");

    // Files with significant coverage changes
    const significantChanges = comparison.filesChanged.filter(
      (f) => Math.abs(f.deltaLineRate) >= 5
    );

    if (significantChanges.length > 0) {
      const improved = significantChanges.filter((f) => f.deltaLineRate > 0);
      const degraded = significantChanges.filter((f) => f.deltaLineRate < 0);

      if (degraded.length > 0) {
        lines.push(
          `#### ğŸ“‰ Files with Decreased Coverage (${degraded.length})`
        );
        lines.push("");
        lines.push("<details>");
        lines.push("<summary>View files with decreased coverage</summary>");
        lines.push("");
        lines.push("| File | Line Coverage Change | Branch Coverage Change |");
        lines.push("|------|---------------------|------------------------|");

        for (const file of degraded.slice(0, 10)) {
          const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
          lines.push(
            `| \`${fileName}\` | ${this.formatCoverageDelta(file.deltaLineRate)}% (${file.baseLineRate}% â†’ ${file.currentLineRate}%) | ${this.formatCoverageDelta(file.deltaBranchRate)}% |`
          );
        }

        lines.push("");
        lines.push("</details>");
        lines.push("");
      }

      if (improved.length > 0) {
        lines.push(
          `#### ğŸ“ˆ Files with Improved Coverage (${improved.length})`
        );
        lines.push("");
        lines.push("<details>");
        lines.push("<summary>View files with improved coverage</summary>");
        lines.push("");
        lines.push("| File | Line Coverage Change | Branch Coverage Change |");
        lines.push("|------|---------------------|------------------------|");

        for (const file of improved.slice(0, 10)) {
          const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
          lines.push(
            `| \`${fileName}\` | ${this.formatCoverageDelta(file.deltaLineRate)}% (${file.baseLineRate}% â†’ ${file.currentLineRate}%) | ${this.formatCoverageDelta(file.deltaBranchRate)}% |`
          );
        }

        lines.push("");
        lines.push("</details>");
        lines.push("");
      }
    }

    // New files
    if (comparison.filesAdded.length > 0) {
      lines.push(`#### â• New Files with Coverage (${comparison.filesAdded.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View new files</summary>");
      lines.push("");
      lines.push("| File | Line Coverage | Branch Coverage |");
      lines.push("|------|---------------|-----------------|");

      for (const file of comparison.filesAdded.slice(0, 10)) {
        const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
        lines.push(
          `| \`${fileName}\` | ${this.getCoverageEmoji(file.lineRate)} ${file.lineRate}% | ${this.getCoverageEmoji(file.branchRate)} ${file.branchRate}% |`
        );
      }

      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Removed files
    if (comparison.filesRemoved.length > 0) {
      lines.push(`#### â– Removed Files (${comparison.filesRemoved.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View removed files</summary>");
      lines.push("");
      for (const file of comparison.filesRemoved.slice(0, 10)) {
        lines.push(`- \`${file.name}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  /**
   * Add comparison section to the comment
   */
  private addComparisonSection(
    lines: string[],
    comparison: TestComparison
  ): void {
    lines.push("### ğŸ“Š Comparison with Base Branch");
    lines.push("");

    // Summary table
    lines.push("| Metric | Change |");
    lines.push("|--------|--------|");
    lines.push(`| Total Tests | ${this.formatDelta(comparison.deltaTotal)} |`);
    lines.push(`| Passed Tests | ${this.formatDelta(comparison.deltaPassed)} |`);
    lines.push(`| Failed Tests | ${this.formatDelta(comparison.deltaFailed)} |`);
    lines.push(`| Skipped Tests | ${this.formatDelta(comparison.deltaSkipped)} |`);
    lines.push("");

    // Tests broken (regressions)
    if (comparison.testsBroken.length > 0) {
      lines.push(`#### ğŸ”´ Tests Broken (${comparison.testsBroken.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View broken tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsBroken) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Error:** ${testChange.testCase.failure.message}`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests fixed (improvements)
    if (comparison.testsFixed.length > 0) {
      lines.push(`#### ğŸŸ¢ Tests Fixed (${comparison.testsFixed.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View fixed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsFixed) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests added
    if (comparison.testsAdded.length > 0) {
      lines.push(`#### â• New Tests (${comparison.testsAdded.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View new tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsAdded) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Status:** âŒ Failing`);
        } else {
          lines.push(`  - **Status:** âœ… Passing`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests removed
    if (comparison.testsRemoved.length > 0) {
      lines.push(`#### â– Removed Tests (${comparison.testsRemoved.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View removed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsRemoved) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Summary message
    if (
      comparison.testsBroken.length === 0 &&
      comparison.testsFixed.length === 0 &&
      comparison.testsAdded.length === 0 &&
      comparison.testsRemoved.length === 0
    ) {
      lines.push("âœ¨ No test changes detected");
      lines.push("");
    }
  }

  /**
   * Format a delta value with appropriate sign and emoji
   */
  private formatDelta(delta: number): string {
    if (delta === 0) {
      return "â€”";
    }
    const sign = delta > 0 ? "+" : "";
    const emoji = delta > 0 ? "ğŸ“ˆ" : "ğŸ“‰";
    return `${emoji} ${sign}${delta}`;
  }

  /**
   * Format a coverage delta value with appropriate sign
   */
  private formatCoverageDelta(delta: number): string {
    if (delta === 0) {
      return "Â±0.00";
    }
    const sign = delta > 0 ? "+" : "";
    return `${sign}${delta.toFixed(2)}`;
  }

  /**
   * Get emoji based on coverage percentage
   */
  private getCoverageEmoji(coverage: number): string {
    if (coverage >= 80) return "ğŸŸ¢";
    if (coverage >= 50) return "ğŸŸ¡";
    if (coverage > 0) return "ğŸ”´";
    return "âšª";
  }

  /**
   * Calculate method coverage percentage
   */
  private calculateMethodCoverage(results: AggregatedCoverageResults): number {
    if (results.totalMethods === 0) return 0;
    return Number.parseFloat(
      ((results.coveredMethods / results.totalMethods) * 100).toFixed(2)
    );
  }

  /**
   * Format execution time in a human-readable way
   */
  private formatTime(seconds: number): string {
    if (seconds < 1) {
      return `${Math.round(seconds * 1000)}ms`;
    }
    if (seconds < 60) {
      return `${seconds.toFixed(2)}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
  }

  /**
   * Generate a unique identifier for the comment
   * This helps identify comments created by this action
   */
  static getCommentIdentifier(): string {
    return "<!-- codecov-action-results -->";
  }

  /**
   * Legacy identifier for backward compatibility
   */
  static getLegacyCommentIdentifier(): string {
    return "<!-- codecov-action-test-results -->";
  }

  /**
   * Add identifier to comment body
   */
  addIdentifier(comment: string): string {
    return `${PRCommentFormatter.getCommentIdentifier()}\n${comment}`;
  }
}
