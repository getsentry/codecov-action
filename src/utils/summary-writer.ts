import * as core from "@actions/core";
import type { AggregatedTestResults } from "../types/test-results.js";
import type { AggregatedCoverageResults } from "../types/coverage.js";

/**
 * Write test results and coverage to GitHub Actions Job Summary
 */
export async function writeJobSummary(
  testResults?: AggregatedTestResults,
  coverageResults?: AggregatedCoverageResults
): Promise<void> {
  const summary = core.summary;

  // Main header
  summary.addHeading("Codecov Action Results ğŸ“Š", 1);

  // Add test results section
  if (testResults) {
    await addTestResultsSection(summary, testResults);
  }

  // Add coverage section
  if (coverageResults) {
    await addCoverageSection(summary, coverageResults);
  }

  // Footer
  summary.addRaw("\n---\n*Generated by Codecov Action*\n");

  // Write the summary
  await summary.write();
}

/**
 * Add test results section to job summary
 */
async function addTestResultsSection(
  summary: typeof core.summary,
  results: AggregatedTestResults
): Promise<void> {
  summary.addHeading("Test Results ğŸ§ª", 2);

  // Summary table
  const passEmoji = results.passedTests > 0 ? "âœ…" : "";
  const failEmoji = results.failedTests > 0 ? "âŒ" : "";
  const skipEmoji = results.skippedTests > 0 ? "â­ï¸" : "";

  summary.addTable([
    [
      { data: "Metric", header: true },
      { data: "Value", header: true },
    ],
    ["Total Tests", results.totalTests.toString()],
    ["Passed", `${passEmoji} ${results.passedTests}`],
    ["Failed", `${failEmoji} ${results.failedTests}`],
    ["Skipped", `${skipEmoji} ${results.skippedTests}`],
    ["Pass Rate", `${results.passRate}%`],
    ["Execution Time", formatTime(results.totalTime)],
  ]);

  // Add comparison section if available
  if (results.comparison) {
    summary.addHeading("ğŸ“Š Comparison with Base Branch", 3);

    summary.addTable([
      [
        { data: "Metric", header: true },
        { data: "Change", header: true },
      ],
      ["Total Tests", formatDelta(results.comparison.deltaTotal)],
      ["Passed Tests", formatDelta(results.comparison.deltaPassed)],
      ["Failed Tests", formatDelta(results.comparison.deltaFailed)],
      ["Skipped Tests", formatDelta(results.comparison.deltaSkipped)],
    ]);

    // Tests broken (regressions)
    if (results.comparison.testsBroken.length > 0) {
      const brokenTestsList = results.comparison.testsBroken
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname})${t.testCase.failure ? `: ${t.testCase.failure.message}` : ""}`
        )
        .join("\n");

      summary.addDetails(
        `ğŸ”´ Tests Broken (${results.comparison.testsBroken.length})`,
        brokenTestsList
      );
    }

    // Tests fixed
    if (results.comparison.testsFixed.length > 0) {
      const fixedTestsList = results.comparison.testsFixed
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `ğŸŸ¢ Tests Fixed (${results.comparison.testsFixed.length})`,
        fixedTestsList
      );
    }

    // Tests added
    if (results.comparison.testsAdded.length > 0) {
      const addedTestsList = results.comparison.testsAdded
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname}) ${t.testCase.failure ? "âŒ" : "âœ…"}`
        )
        .join("\n");

      summary.addDetails(
        `â• New Tests (${results.comparison.testsAdded.length})`,
        addedTestsList
      );
    }

    // Tests removed
    if (results.comparison.testsRemoved.length > 0) {
      const removedTestsList = results.comparison.testsRemoved
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `â– Removed Tests (${results.comparison.testsRemoved.length})`,
        removedTestsList
      );
    }
  }

  // Show failed tests if any
  if (results.failedTests > 0 && results.failedTestCases.length > 0) {
    summary.addHeading("âŒ Failed Tests", 3);

    for (const { suiteName, testCase } of results.failedTestCases) {
      const testHeader = `\`${testCase.name}\``;
      let details = `**File:** \`${testCase.classname}\`\n`;

      if (suiteName && suiteName !== testCase.classname) {
        details += `**Suite:** \`${suiteName}\`\n`;
      }

      if (testCase.failure) {
        details += `**Error:** ${testCase.failure.message}\n`;

        if (testCase.failure.content) {
          details += `\n\`\`\`\n${testCase.failure.content.trim()}\n\`\`\`\n`;
        }
      }

      summary.addDetails(testHeader, details);
    }
  } else if (results.failedTests === 0) {
    summary.addRaw("\n### âœ… All Tests Passed!\n\nGreat job! All tests are passing successfully.\n\n");
  }
}

/**
 * Add coverage section to job summary
 */
async function addCoverageSection(
  summary: typeof core.summary,
  results: AggregatedCoverageResults
): Promise<void> {
  summary.addHeading("Coverage Report ğŸ¯", 2);

  // Coverage summary table
  const lineEmoji = getCoverageEmoji(results.lineRate);
  const branchEmoji = getCoverageEmoji(results.branchRate);
  const methodCoverage = results.totalMethods > 0
    ? ((results.coveredMethods / results.totalMethods) * 100).toFixed(2)
    : "0";

  summary.addTable([
    [
      { data: "Metric", header: true },
      { data: "Coverage", header: true },
      { data: "Covered/Total", header: true },
    ],
    [
      `${lineEmoji} Line Coverage`,
      `${results.lineRate}%`,
      `${results.coveredStatements}/${results.totalStatements}`,
    ],
    [
      `${branchEmoji} Branch Coverage`,
      `${results.branchRate}%`,
      `${results.coveredConditionals}/${results.totalConditionals}`,
    ],
    [
      `ğŸ”§ Method Coverage`,
      `${methodCoverage}%`,
      `${results.coveredMethods}/${results.totalMethods}`,
    ],
  ]);

  // Add comparison section if available
  if (results.comparison) {
    summary.addHeading("ğŸ“Š Coverage Change from Base Branch", 3);

    // Improvement or degradation indicator
    if (results.comparison.improvement) {
      summary.addRaw("\n#### ğŸ“ˆ Coverage Improved!\n\n");
    } else if (
      results.comparison.deltaLineRate < 0 ||
      results.comparison.deltaBranchRate < 0
    ) {
      summary.addRaw("\n#### ğŸ“‰ Coverage Decreased\n\n");
    } else {
      summary.addRaw("\n#### â¡ï¸ Coverage Unchanged\n\n");
    }

    summary.addTable([
      [
        { data: "Metric", header: true },
        { data: "Change", header: true },
      ],
      ["Line Coverage", `${formatCoverageDelta(results.comparison.deltaLineRate)}%`],
      ["Branch Coverage", `${formatCoverageDelta(results.comparison.deltaBranchRate)}%`],
      ["Total Statements", formatDelta(results.comparison.deltaTotalStatements)],
      ["Covered Statements", formatDelta(results.comparison.deltaCoveredStatements)],
    ]);

    // Files with significant coverage changes
    const significantChanges = results.comparison.filesChanged.filter(
      (f) => Math.abs(f.deltaLineRate) >= 5
    );

    if (significantChanges.length > 0) {
      const degraded = significantChanges.filter((f) => f.deltaLineRate < 0);
      const improved = significantChanges.filter((f) => f.deltaLineRate > 0);

      if (degraded.length > 0) {
        const degradedList = degraded
          .slice(0, 10)
          .map(
            (f) =>
              `- \`${f.name.length > 40 ? `...${f.name.slice(-37)}` : f.name}\`: ${formatCoverageDelta(f.deltaLineRate)}% (${f.baseLineRate}% â†’ ${f.currentLineRate}%)`
          )
          .join("\n");

        summary.addDetails(
          `ğŸ“‰ Files with Decreased Coverage (${degraded.length})`,
          degradedList
        );
      }

      if (improved.length > 0) {
        const improvedList = improved
          .slice(0, 10)
          .map(
            (f) =>
              `- \`${f.name.length > 40 ? `...${f.name.slice(-37)}` : f.name}\`: ${formatCoverageDelta(f.deltaLineRate)}% (${f.baseLineRate}% â†’ ${f.currentLineRate}%)`
          )
          .join("\n");

        summary.addDetails(
          `ğŸ“ˆ Files with Improved Coverage (${improved.length})`,
          improvedList
        );
      }
    }

    // New files
    if (results.comparison.filesAdded.length > 0) {
      const addedList = results.comparison.filesAdded
        .slice(0, 10)
        .map(
          (f) =>
            `- \`${f.name.length > 40 ? `...${f.name.slice(-37)}` : f.name}\`: ${getCoverageEmoji(f.lineRate)} ${f.lineRate}%`
        )
        .join("\n");

      summary.addDetails(
        `â• New Files with Coverage (${results.comparison.filesAdded.length})`,
        addedList
      );
    }

    // Removed files
    if (results.comparison.filesRemoved.length > 0) {
      const removedList = results.comparison.filesRemoved
        .slice(0, 10)
        .map((f) => `- \`${f.name}\``)
        .join("\n");

      summary.addDetails(
        `â– Removed Files (${results.comparison.filesRemoved.length})`,
        removedList
      );
    }
  }

  // Show files with low coverage (< 50%)
  const lowCoverageFiles = results.files.filter(
    (f) => f.lineRate < 50 && f.lineRate > 0
  );

  if (lowCoverageFiles.length > 0) {
    const sortedFiles = lowCoverageFiles
      .sort((a, b) => a.lineRate - b.lineRate)
      .slice(0, 10);

    const lowCoverageList = sortedFiles
      .map(
        (f) =>
          `- \`${f.name.length > 50 ? `...${f.name.slice(-47)}` : f.name}\`: ${getCoverageEmoji(f.lineRate)} ${f.lineRate}% line, ${getCoverageEmoji(f.branchRate)} ${f.branchRate}% branch`
      )
      .join("\n");

    summary.addDetails(
      `âš ï¸ Files with Low Coverage (${lowCoverageFiles.length})`,
      lowCoverageList + (lowCoverageFiles.length > 10 ? `\n\n...and ${lowCoverageFiles.length - 10} more files` : "")
    );
  }
}

/**
 * Format a delta value with appropriate sign and emoji
 */
function formatDelta(delta: number): string {
  if (delta === 0) {
    return "â€”";
  }
  const sign = delta > 0 ? "+" : "";
  const emoji = delta > 0 ? "ğŸ“ˆ" : "ğŸ“‰";
  return `${emoji} ${sign}${delta}`;
}

/**
 * Format a coverage delta value with appropriate sign
 */
function formatCoverageDelta(delta: number): string {
  if (delta === 0) {
    return "Â±0.00";
  }
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta.toFixed(2)}`;
}

/**
 * Get emoji based on coverage percentage
 */
function getCoverageEmoji(coverage: number): string {
  if (coverage >= 80) return "ğŸŸ¢";
  if (coverage >= 50) return "ğŸŸ¡";
  if (coverage > 0) return "ğŸ”´";
  return "âšª";
}

/**
 * Format execution time in a human-readable way
 */
function formatTime(seconds: number): string {
  if (seconds < 1) {
    return `${Math.round(seconds * 1000)}ms`;
  }
  if (seconds < 60) {
    return `${seconds.toFixed(2)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}

