import * as core from "@actions/core";
import type { AggregatedTestResults } from "../types/test-results.js";
import type { AggregatedCoverageResults } from "../types/coverage.js";

/**
 * Write test results and coverage to GitHub Actions Job Summary
 */
export async function writeJobSummary(
  testResults?: AggregatedTestResults,
  coverageResults?: AggregatedCoverageResults
): Promise<void> {
  const summary = core.summary;

  // Main header
  summary.addHeading("Codecov Action Results üìä", 1);

  // Add test results section
  if (testResults) {
    await addTestResultsSection(summary, testResults);
  }

  // Add coverage section
  if (coverageResults) {
    await addCoverageSection(summary, coverageResults);
  }

  // Footer
  summary.addRaw("\n---\n*Generated by Codecov Action*\n");

  // Write the summary
  await summary.write();
}

/**
 * Add test results section to job summary
 */
async function addTestResultsSection(
  summary: typeof core.summary,
  results: AggregatedTestResults
): Promise<void> {
  summary.addHeading("Test Results üß™", 2);

  // Summary table
  const passEmoji = results.passedTests > 0 ? "‚úÖ" : "";
  const failEmoji = results.failedTests > 0 ? "‚ùå" : "";
  const skipEmoji = results.skippedTests > 0 ? "‚è≠Ô∏è" : "";

  summary.addTable([
    [
      { data: "Metric", header: true },
      { data: "Value", header: true },
    ],
    ["Total Tests", results.totalTests.toString()],
    ["Passed", `${passEmoji} ${results.passedTests}`],
    ["Failed", `${failEmoji} ${results.failedTests}`],
    ["Skipped", `${skipEmoji} ${results.skippedTests}`],
    ["Pass Rate", `${results.passRate}%`],
    ["Execution Time", formatTime(results.totalTime)],
  ]);

  // Add comparison section if available
  if (results.comparison) {
    summary.addHeading("üìä Comparison with Base Branch", 3);

    summary.addTable([
      [
        { data: "Metric", header: true },
        { data: "Change", header: true },
      ],
      ["Total Tests", formatDelta(results.comparison.deltaTotal)],
      ["Passed Tests", formatDelta(results.comparison.deltaPassed)],
      ["Failed Tests", formatDelta(results.comparison.deltaFailed)],
      ["Skipped Tests", formatDelta(results.comparison.deltaSkipped)],
    ]);

    // Tests broken (regressions)
    if (results.comparison.testsBroken.length > 0) {
      const brokenTestsList = results.comparison.testsBroken
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname})${t.testCase.failure ? `: ${t.testCase.failure.message}` : ""}`
        )
        .join("\n");

      summary.addDetails(
        `üî¥ Tests Broken (${results.comparison.testsBroken.length})`,
        brokenTestsList
      );
    }

    // Tests fixed
    if (results.comparison.testsFixed.length > 0) {
      const fixedTestsList = results.comparison.testsFixed
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `üü¢ Tests Fixed (${results.comparison.testsFixed.length})`,
        fixedTestsList
      );
    }

    // Tests added
    if (results.comparison.testsAdded.length > 0) {
      const addedTestsList = results.comparison.testsAdded
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname}) ${t.testCase.failure ? "‚ùå" : "‚úÖ"}`
        )
        .join("\n");

      summary.addDetails(
        `‚ûï New Tests (${results.comparison.testsAdded.length})`,
        addedTestsList
      );
    }

    // Tests removed
    if (results.comparison.testsRemoved.length > 0) {
      const removedTestsList = results.comparison.testsRemoved
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `‚ûñ Removed Tests (${results.comparison.testsRemoved.length})`,
        removedTestsList
      );
    }
  }

  // Show failed tests if any
  if (results.failedTests > 0 && results.failedTestCases.length > 0) {
    summary.addHeading("‚ùå Failed Tests", 3);

    for (const { suiteName, testCase } of results.failedTestCases) {
      const testHeader = `\`${testCase.name}\``;
      let details = `**File:** \`${testCase.classname}\`\n`;

      if (suiteName && suiteName !== testCase.classname) {
        details += `**Suite:** \`${suiteName}\`\n`;
      }

      if (testCase.failure) {
        details += `**Error:** ${testCase.failure.message}\n`;

        if (testCase.failure.content) {
          details += `\n\`\`\`\n${testCase.failure.content.trim()}\n\`\`\`\n`;
        }
      }

      summary.addDetails(testHeader, details);
    }
  } else if (results.failedTests === 0) {
    summary.addRaw("\n### ‚úÖ All Tests Passed!\n\nGreat job! All tests are passing successfully.\n\n");
  }
}

/**
 * Add coverage section to job summary (Codecov-style format with icons)
 */
async function addCoverageSection(
  summary: typeof core.summary,
  results: AggregatedCoverageResults
): Promise<void> {
  summary.addHeading("Codecov Report", 2);

  // Calculate metrics
  const totalMissing = results.totalMisses || 0;

  // Line 1: Patch coverage with missing lines
  if (totalMissing > 0) {
    summary.addRaw(
      `\n‚ùå Patch coverage is **${results.lineRate}%** with **${totalMissing} lines** missing coverage.\n`
    );
  } else {
    summary.addRaw(`\n‚úÖ Patch coverage is **${results.lineRate}%**.\n`);
  }

  // Line 2: Project coverage with comparison info
  if (results.comparison) {
    const baseRef = results.comparison.baseCommit
      ? `\`${results.comparison.baseCommit.substring(0, 7)}\``
      : "`base`";
    const headRef = results.comparison.headCommit
      ? `\`${results.comparison.headCommit.substring(0, 7)}\``
      : "`head`";
    const emoji = results.comparison.improvement ? "‚úÖ" : results.comparison.deltaLineRate < 0 ? "‚ùå" : "‚úÖ";
    summary.addRaw(
      `${emoji} Project coverage is **${results.lineRate}%**. Comparing base (${baseRef}) to head (${headRef}).\n\n`
    );
  } else {
    summary.addRaw("\n");
  }

  // Files with missing lines (top 10 visible, rest collapsed)
  const filesWithMissing = results.files
    .filter((f) => (f.missingLines?.length || 0) > 0 || (f.partialLines?.length || 0) > 0)
    .sort((a, b) => {
      const aMissing = (a.missingLines?.length || 0) + (a.partialLines?.length || 0);
      const bMissing = (b.missingLines?.length || 0) + (b.partialLines?.length || 0);
      return bMissing - aMissing;
    });

  if (filesWithMissing.length > 0) {
    summary.addHeading("Files with missing lines", 3);

    // Build visible table (top 10 files)
    const visibleFiles = filesWithMissing.slice(0, 10);
    const remainingFiles = filesWithMissing.slice(10);

    const tableData: Array<Array<string | { data: string; header: boolean }>> = [
      [
        { data: "File", header: true },
        { data: "Patch %", header: true },
        { data: "Lines", header: true },
      ],
    ];

    for (const file of visibleFiles) {
      const fileName = getFileName(file.path);
      const missingCount = file.missingLines?.length || 0;
      const partialCount = file.partialLines?.length || 0;

      let linesText = "";
      if (missingCount > 0 && partialCount > 0) {
        linesText = `‚ö†Ô∏è ${missingCount} Missing and ${partialCount} partials`;
      } else if (missingCount > 0) {
        linesText = `‚ö†Ô∏è ${missingCount} Missing`;
      } else if (partialCount > 0) {
        linesText = `‚ö†Ô∏è ${partialCount} partials`;
      }

      tableData.push([`\`${fileName}\``, `${file.lineRate.toFixed(2)}%`, linesText]);
    }

    summary.addTable(tableData);

    // Remaining files in collapsed section
    if (remainingFiles.length > 0) {
      const remainingRows = remainingFiles.map((file) => {
        const fileName = getFileName(file.path);
        const missingCount = file.missingLines?.length || 0;
        const partialCount = file.partialLines?.length || 0;

        let linesText = "";
        if (missingCount > 0 && partialCount > 0) {
          linesText = `‚ö†Ô∏è ${missingCount} Missing and ${partialCount} partials`;
        } else if (missingCount > 0) {
          linesText = `‚ö†Ô∏è ${missingCount} Missing`;
        } else if (partialCount > 0) {
          linesText = `‚ö†Ô∏è ${partialCount} partials`;
        }

        return `| \`${fileName}\` | ${file.lineRate.toFixed(2)}% | ${linesText} |`;
      });

      const remainingTable = `| File | Patch % | Lines |\n|------|---------|-------|\n${remainingRows.join("\n")}`;
      summary.addDetails(
        `${remainingFiles.length} more files with missing coverage`,
        remainingTable
      );
    }
  }

  // Coverage diff in diff code block format
  if (results.comparison) {
    const comparison = results.comparison;
    const baseBranch = comparison.baseBranch || "main";
    const prLabel = "#PR";

    const diffLines: string[] = [];
    diffLines.push("```diff");
    diffLines.push("@@            Coverage Diff             @@");
    diffLines.push(`##    ${padCol(baseBranch, 10)}${padCol(prLabel, 10)}${padCol("+/-", 10)}##`);
    diffLines.push("==========================================");

    // Coverage line (green if improved)
    const baseCoverage = (results.lineRate - comparison.deltaLineRate).toFixed(2) + "%";
    const currentCoverage = results.lineRate.toFixed(2) + "%";
    const coverageDelta = formatDeltaSimple(comparison.deltaLineRate) + "%";
    const coveragePrefix = comparison.deltaLineRate >= 0 ? "+" : "-";
    diffLines.push(`${coveragePrefix} Coverage${padCol(baseCoverage, 10)}${padCol(currentCoverage, 10)}${padCol(coverageDelta, 10)}`);

    diffLines.push("==========================================");

    // Neutral metrics (Files, Lines, Branches)
    const baseFiles = String(comparison.baseFiles || 0);
    const currentFiles = String(comparison.currentFiles || 0);
    const deltaFiles = formatDeltaSimple(comparison.deltaFiles || 0);
    diffLines.push(`  Files   ${padCol(baseFiles, 10)}${padCol(currentFiles, 10)}${padCol(deltaFiles, 10)}`);

    const baseLines = String(comparison.baseLines || 0);
    const currentLines = String(comparison.currentLines || 0);
    const deltaLines = formatDeltaSimple(comparison.deltaLines || 0);
    diffLines.push(`  Lines   ${padCol(baseLines, 10)}${padCol(currentLines, 10)}${padCol(deltaLines, 10)}`);

    const baseBranches = String(comparison.baseBranches || 0);
    const currentBranches = String(comparison.currentBranches || 0);
    const deltaBranches = formatDeltaSimple(comparison.deltaBranches || 0);
    diffLines.push(`  Branches${padCol(baseBranches, 10)}${padCol(currentBranches, 10)}${padCol(deltaBranches, 10)}`);

    diffLines.push("==========================================");

    // Hits (green - positive indicator)
    const baseHits = String(comparison.baseHits || 0);
    const currentHits = String(comparison.currentHits || 0);
    const deltaHits = formatDeltaSimple(comparison.deltaHits || 0);
    diffLines.push(`+ Hits    ${padCol(baseHits, 10)}${padCol(currentHits, 10)}${padCol(deltaHits, 10)}`);

    // Misses (red - negative indicator)
    const baseMisses = String(comparison.baseMisses || 0);
    const currentMisses = String(comparison.currentMisses || 0);
    const deltaMisses = formatDeltaSimple(comparison.deltaMisses || 0);
    diffLines.push(`- Misses  ${padCol(baseMisses, 10)}${padCol(currentMisses, 10)}${padCol(deltaMisses, 10)}`);

    // Partials (red - negative indicator)
    const basePartials = String(comparison.basePartials || 0);
    const currentPartials = String(comparison.currentPartials || 0);
    const deltaPartials = formatDeltaSimple(comparison.deltaPartials || 0);
    diffLines.push(`- Partials${padCol(basePartials, 10)}${padCol(currentPartials, 10)}${padCol(deltaPartials, 10)}`);

    diffLines.push("```");

    summary.addDetails("Coverage diff", diffLines.join("\n"));
  }

  // Flags section (only if flags exist)
  if (results.flags && results.flags.length > 0) {
    const flagsList = results.flags
      .map((flag) => {
        const change = results.comparison
          ? ` (${formatCoverageDelta(results.comparison.deltaLineRate)}%)`
          : "";
        return `- \`${flag}\`: ${results.lineRate}%${change}`;
      })
      .join("\n");

    summary.addDetails(`Flags (${results.flags.length})`, flagsList);
  }
}

/**
 * Get just the filename from a path
 */
function getFileName(path: string): string {
  return path.split("/").pop() || path;
}

/**
 * Pad a column value for alignment
 */
function padCol(value: string, width: number): string {
  return value.padStart(width);
}

/**
 * Format delta value with sign only (no emoji)
 */
function formatDeltaSimple(delta: number): string {
  if (delta === 0) return "‚Äî";
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta}`;
}

/**
 * Format a delta value with appropriate sign and emoji
 */
function formatDelta(delta: number): string {
  if (delta === 0) {
    return "‚Äî";
  }
  const sign = delta > 0 ? "+" : "";
  const emoji = delta > 0 ? "üìà" : "üìâ";
  return `${emoji} ${sign}${delta}`;
}

/**
 * Format a coverage delta value with appropriate sign
 */
function formatCoverageDelta(delta: number): string {
  if (delta === 0) {
    return "¬±0.00";
  }
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta.toFixed(2)}`;
}

/**
 * Format execution time in a human-readable way
 */
function formatTime(seconds: number): string {
  if (seconds < 1) {
    return `${Math.round(seconds * 1000)}ms`;
  }
  if (seconds < 60) {
    return `${seconds.toFixed(2)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}

